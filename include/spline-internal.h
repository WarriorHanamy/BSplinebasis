#ifndef MYSPLINE_INTERNAL_H
#define MYSPLINE_INTERNAL_H
#include <vector>
#include <assert.h>
#include <array>
#include <memory>

/*
 * ########################################################################
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * ########################################################################
 */

namespace myspline::internal {


/*!
 * Represents the support of a spline as a number of gridpoints. Keeps a shared_ptr to the global grid to check whether two splines are defined on the same grid.
 *
 * @tparam T Datatype of the grid and spline.
 */
template<typename T>
class support {
    private:
        std::shared_ptr<const std::vector<T>> _grid; /*! Represents the global grid. */
        size_t _startIndex; /*! Represents the begin of the support. */
        size_t _endIndex; /*! Represents the end of the support. Points to the element behind the last element of the support. */

    public:

        /*!
         * Constructs a support relative to the global grid grid. 
         *
         * @param grid The global grid.
         * @param startIndex The index of the first grid point which is part of the support.
         * @param endIndex The index of the element behind the last grid point which is part of the support.
         */
        support(std::shared_ptr<const std::vector<T>> grid, size_t startIndex, size_t endIndex): _grid(grid), 
                                                                                                 _startIndex((endIndex > startIndex) ? startIndex : 0), 
                                                                                                 _endIndex((endIndex > startIndex) ? endIndex : 0) {
             assert(_endIndex <= grid->size());
        };

        /*!
         * Constructs an empty support relative to the global grid grid.
         *
         * @param grid The global grid.
         */
        support(std::shared_ptr<const std::vector<T>> grid): _grid(grid), _startIndex(0), _endIndex(0) {};


        // Default constructors and operators generated by the compiler.
        support() = default;
        support(const support &s) = default;
        support(support &&s) = default;
        ~support() = default;
        support& operator=(const support &s) = default;
        support& operator=(support &&s) = default;


       /*!
        * Returns the number of grid points contained in the support.
        */
        size_t size() const {
            return _endIndex - _startIndex;
        };

        /*!
         * Checks whether the number of grid points contained in the support is zero.
         */
        bool empty() const {
            return (_startIndex == _endIndex);
        };

        /*!
         * Returns the global grid.
         */
        std::shared_ptr<const std::vector<T>> getGrid() const {
            return _grid;
        };

        /*!
         * Returns the _startIndex.
         */
        size_t getStartIndex() const {
            return _startIndex;
        };

        /*!
         * Returns the _endIndex.
         */
        size_t getEndIndex() const {
            return _endIndex;
        }

        /*!
         * Allows access to the grid points contained in the support. Performs no bounds checks.
         *
         * @param index Index of the element.
         */
        const T& operator[](size_t index) const {
            return grid->[_startIndex + index];
        };

        /*!
         * Allows access to the grid points contained in the support. Checks bounds via an assert.
         *
         * @param index Index of the element.
         */
        const T& at(size_t index) const {
            assert(_startIndex + index < _endIndex);
            return grid->at(_startIndex + index);
        };

        /*!
         * Returns a reference to the first grid point that is part of the support.
         */
        const T& front() const {
            assert(!empty());
            return _grid->[_startIndex];
        };

        /*!
         * Returns a reference to the last grid point that is part of the support.
         */
        const T& back() const {
            assert(!empty());
            return _grid->[_endIndex -1];
        };


        /*!
         * Checks whether the global grids, the two supports are defined on, are logically equivalent.
         *
         * @param s Support to check against.
         */
        bool hasSameGrid(const support &s) const {
            if (_grid == s._grid) return true;
            else if (_grid->size() != s._grid->size()) return false;
            for (size_t i = 0; i < _grid->size(); i++) if (_grid->[i] != s._grid->[i]) return false;
            return true;
        };


       /*!
        * Calculates the union of this support with the support s. This is not strictly the set-theoretical union (if the two supports do not overlap),
        * but a support representing one contiguous bit of the number line containing both supports.
        * 
        * @param s The support to calculate the union with.
        */
       support calculateUnion(const support &s) const {
           assert(hasSameGrid(s));
           bool thisContainsNoIntervals = (size() <= 1); // The number of intervals contained in the support is size() - 1. 
           bool sContainsNoIntervals = (s.size() <= 1); // The number of intervals contained in the support is size() - 1. 
           if (thisContainsNoIntervals && sContainsNoIntervals) return support(_grid); // Both supports contain no intervals, return empty support
           else if (thisContainsNoIntervals && !sContainsNoIntervals) return s;
           else if (!thisContainsNoIntervals && sContainsNoIntervals) return *this;
           size_t newStartIndex = std::min(_startIndex, s._startIndex);
           size_t newEndIndex = std::max(_endIndex, s._endIndex);
           return support(_grid, newStartIndex, newEndIndex);
       };

       /*!
        * Calculates the intersection of the two supports.
        *
        * @param s The support to calculate the intersection with.
        */ 
       support calculateIntersection(const support &s) const {
           assert(hasSameGrid(s));
           size_t newStartIndex = std::max(_startIndex, s._startIndex);
           size_t newEndIndex = std::min(_endIndex, s._endIndex);
           if (newStartIndex >= newEndIndex) return support(_grid); // no overlap, return empty support
           else return support(_grid, newStartIndex, _newEndIndex);
       };           

}; // end class support
}; // end namespace myspline::internal
#endif // MYSPLINE_INTERNAL_H
